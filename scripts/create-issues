#!/usr/bin/python3
import pycurl
import certifi
from io import BytesIO
import os
import json
import re

issue_repo = ""
current_repo = ""
log_dir = ""
github_user = ""
github_token = ""
dry_run = False


def get_exist_err_packs():
    url = 'https://api.github.com/repos/{}/issues'.format(issue_repo)
    exist_err_packs = []
    while True:
        buffer = BytesIO()
        header = BytesIO()
        c = pycurl.Curl()
        c.setopt(c.URL, url)
        c.setopt(pycurl.WRITEFUNCTION, buffer.write)
        c.setopt(pycurl.HEADERFUNCTION, header.write)
        c.setopt(c.CAINFO, certifi.where())
        c.perform()
        c.close()
        body = buffer.getvalue().decode('UTF-8')
        # print(body)
        issues = json.loads(body)
        # print(issues)
        for issue in issues:
            err_packs = re.findall(
                'ERROR: (.*) failed to build', issue['title'])
            exist_err_packs.extend(err_packs)
            pass
        next_link = re.findall('<(.*?)>.*?rel="next"',
                               header.getvalue().decode('UTF-8'))
        if len(next_link) == 0:
            break
        url = next_link[0]
    return set(exist_err_packs)


def readme_intend_sta(title, intend=0):
    ans = ""
    for i in range(intend):
        ans += "    "
    ans += " -  <details><summary>{}</summary>\n\n".format(title)
    return ans


def readme_intend_end(intend=0):
    ans = ""
    for i in range(intend):
        ans += "    "
    ans += "    </details>\n"
    return ans


def readme_intend_cont(conts, intend=0):
    itd = "    "
    for i in range(intend):
        itd += "    "
    return conts.replace('\n', '\n'+itd)


def create_issue(pack_name):
    issue_log_dir = '%s/%s' % (log_dir, pack_name)
    # print(compile_log_path)
    readme_contents = ""
    for curdir, subdirs, files in os.walk(issue_log_dir):
        if len(subdirs) != 0:
            continue
        if len(files) == 0:
            continue
        readme_contents += readme_intend_sta(curdir[len(log_dir)+1:])
        for file in files:
            readme_contents += readme_intend_sta(file, 1)
            log_detail = "\n```\n"
            with open('%s/%s' % (curdir, file), 'r') as f:
                log_detail += f.read()
            log_detail += "\n```"
            readme_contents += readme_intend_cont(log_detail, 1)+'\n'
            readme_contents += readme_intend_end(1)
        readme_contents += readme_intend_end()
    # print(readme_contents)
    # with open('output', 'w') as f:
    #     f.write(readme_contents)
    # exit(0)
    config_contents = "Sorry, configuration missing."
    config_path = "%s/minial_config" % log_dir
    if os.path.exists(config_path) and os.path.isfile(config_path):
        with open(config_path, 'r') as f:
            config_contents = f.read()
    c = pycurl.Curl()
    c.setopt(c.URL, 'https://api.github.com/repos/{}/issues'.format(issue_repo))
    c.setopt(c.CAINFO, certifi.where())
    c.setopt(c.CUSTOMREQUEST, 'POST')
    c.setopt(c.USERNAME, github_user)
    c.setopt(c.PASSWORD, github_token)
    buffer = BytesIO()
    c.setopt(pycurl.WRITEFUNCTION, buffer.write)

    post_data = {
        'title': 'ERROR: %s failed to build' % pack_name,
        'body':
        '''
Package `{0}` compiled error.
Dalao fix it, please!

> Note: This issue is created from [{1}](https://github.com/{1}) action

---

<details><summary>Log detail</summary>

{2}

</details>

<details><summary>Configuration detail</summary>

```
{3}
```
</details>

        '''.format(pack_name, current_repo, readme_contents, config_contents),
    }
    # print(post_data['body'])
    # return
    c.setopt(c.POSTFIELDS, json.dumps(post_data))
    if dry_run == False:
        c.perform()
    c.close()
    print("created issue: %s" % pack_name)
    pass


def extra_err_packs():
    compiled_err_issues = []
    log_path = "%s/log.out" % log_dir
    if not os.path.exists(log_path) or not os.path.isfile(log_path):
        print("Log path not exist: %s" % log_path)
        exit(1)
    with open(log_path, 'r') as f:
        for line in f:
            err_packs = re.findall('ERROR: (.*) failed to build', line)
            compiled_err_issues.extend(err_packs)
    return set(compiled_err_issues)


def main():
    opened_issues = get_exist_err_packs()
    print('opened issues[%s]: %s' % (len(opened_issues), opened_issues))
    compiled_err_issues = extra_err_packs()
    print('current packages need to be fixed: %s' % compiled_err_issues)
    push_issues = compiled_err_issues.difference(opened_issues)
    print('need to create issues: %s' % push_issues)
    for issue in push_issues:
        create_issue(issue)
    pass


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(
        description='Create compiled error issue from Build log')
    parser.add_argument('-d', '--dry-run', action='store_true',
                        help='dry run, not push issues')
    parser.add_argument('-ipo', '--issue-repo', type=str, required=True,
                        help='the github repo name that need to create issues[example: Codertocat/Hello-World]')
    parser.add_argument('-cpo', '--curr-repo', type=str, required=True,
                        help='this repo name[example: Codertocat/Hello-World]')
    parser.add_argument('-l', '--openwrt-logs-dir', type=str, required=True,
                        help='log file path')
    parser.add_argument('-u', '--user', type=str, required=True,
                        help='github user who have permission to delete artifacts')
    parser.add_argument('-t', '--token', type=str, required=True,
                        help='user token')
    args = parser.parse_args()
    issue_repo = args.issue_repo
    current_repo = args.curr_repo
    log_dir = args.openwrt_logs_dir
    github_user = args.user
    github_token = args.token
    dry_run = args.dry_run
    main()
